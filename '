
#include <iostream>

#include "camera.hpp"

enum Groups: FilterGroup {
    Color,
    Range,
};

void mouseCallback(int event, int x, int y, int flags, void* data) {
    if (event != cv::EVENT_LBUTTONDOWN) {
        return;
    }

    cv::Mat* image = reinterpret_cast<cv::Mat*>(data);
    std::cout << x << "\t" << y << ", " << image->at<cv::Vec3b>(cv::Point(x, y)) << "\n";
}

int largestContour(std::vector<std::vector<cv::Point>> contours) {
    int max_contour = 0;
    int max_area = 0;

    for (int i = 0; i < contours.size(); i++) {
        std::vector<cv::Point> polygon;

        cv::approxPolyDP(cv::Mat(contours[i]), polygon, 3, true);
        cv::Rect boundingRect = cv::boundingRect(polygon);

        if (boundingRect.area() > max_area) {
            max_contour = i;
        }
    } 

    return max_contour;
}

int main() {
    Camera cam;
    cv::namedWindow("test", 1);
    cv::setMouseCallback("test", mouseCallback, &cam.filteredFrame);

    cam.addFilter(Groups::Color, [](cv::Mat& src) { 
        cv::cvtColor(src, src, cv::COLOR_BGR2HSV);
    });

    cam.addFilter(Groups::Range, [](cv::Mat& src) {
        cv::inRange(src, cv::Scalar(25, 60, 140), cv::Scalar(170, 210, 210), src);
    });

    while(true) {
        cam.capture({Groups::Color});
        
        std::vector<std::vector<cv::Point>> contours;
        std::vector<cv::Vec4i> hierarchy;

        //cv::findContours(cam.filteredFrame, contours, hierarchy, CV_RETR_LIST, CV_CHAIN_APPROX_NONE, cv::Point(0, 0));

        //int idx = largestContour(contours); 

        //for (int i = 0; i < contours.size(); i++) {
        //    cv::drawContours(cam.rawFrame, contours, i, cv::Scalar(0, 0, 255), 2, 8, hierarchy, 0, cv::Point());
        //}

        //cv::drawContours(cam.filteredFrame, contours, idx, cv::Scalar(0, 0, 255), 2, 8, hierarchy, 0, cv::Point());

        cv::imshow("test", cam.filteredFrame);
        
        if (cv::waitKey(31) >= 0) {
            break;
        }
    }

    return 0;
}
